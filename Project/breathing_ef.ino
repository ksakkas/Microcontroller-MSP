/*
Αυτός ο κωδικός σχεδιάστηκε από τον Κωνσταντίνο Σάκκα στις 7 Αυγούστου 2020.
Προορίζεται για ακαδημαϊκή χρήση στο Τμήμα Πληροφορικής και Τηλεπικοινωνιών του Πανεπιστημίου
Ιωαννίνων και του github https://ksakkas.github.io/Microcontroller-MSP430/.
*/
/*
Αυτός ο κώδικας σχεδιάστηκε και εκτελέστηκε στο πρόγραμμα Energia έκδοσης 1.8.11E23
Σχεδιάστηκε για χρήση με τον μικροεπεξεργαστή MSP430F5529
*/
/*
1* Ο χρήστης μέσω μηνυμάτων θα μπορεί να ελέγχει το duty cycle με το οποίο θα γίνεται η αφέσβεση του πράσινου led της πλακέτας
2* Η αφέσβεση του κόκκινου Led θα ελέγχεται με τη χρήση του button που βρίσκεται στο P1.1
3* Όσο ο χρήσης πιέζει το button, το κόκκινο Led θα πρέπει να αναβοσβήνει σταδιακά (breathing effect)
4* Το κόκκινο led σε κατάσταση ηρεμίας θα πρέπει να διατηρεί την τελευταία κατάσταση που είχε όσο ο χρήστης πίεζε το button
*/

const int button = PUSH2;                                      //Αρχικοποιούμε στην σταθερά button το κουμπί PUSH2 (P1.1)
int buttonCurrent=0;                                          //Αρχικοποιούμε την μεταβλητή buttonCurrent = HIGH δηλαδή λογικό 1
                                                             //Η συγκεκριμένη μεταβλητή θα κρατάει την κατάσταση του κουμπιού
int p,t;                                                     //Μεταβλητές μετρητών κατάστασης λεντ
void setup() {                                             //Συνάρτηση αρχικοποίησης παραμέτρων και υλικών συστήματος
       Serial.begin(9600);                                //Είναι ο ρυθμός μετάδοσης σε bits / sec 
       pinMode(RED_LED, OUTPUT);                         //Δήλωση σταθεράς led = RED_LED ως έξοδο
       pinMode (GREEN_LED, OUTPUT);                     //Δήλωση σταθεράς led = RED_LED ως έξοδο
       pinMode(button, INPUT_PULLUP);                  //Δήλωση σταθεράς button = PUSH2 ως έξοδο
       Serial.println("Department Informatics & Telecommunications ");         //Εμφάνιση μηνύματος στην έναρξη του προγράμματος
       Serial.println("Lab Systems Microprocessors");                         //Εμφάνιση μηνύματος στην έναρξη του προγράμματος
       Serial.println("Give a number for the x of the Duty Cycle");                         //Εμφάνιση μηνύματος στην έναρξη του προγράμματος
}

int k = 20000;                                      //Περίοδος (T)
int i = 0;                                         //Μετρητής
int j = 10;                                       //Time on = d
int l = 50;                                      //Step = Βήμα

void loop() {                                  //Κύρια επαναληπτική συνάρτηση
buttonCurrent = digitalRead(button);          //Εκχώρηση στην μεταβλητή buttonCurrent την τιμή του Button (εαν πατήθηκε ή όχι)
if(Serial.available())                       //Αν η σειριακή είσοδος είναι διαθέσιμη
  {
    if(buttonCurrent != LOW){              //Εαν η τιμή του buttonCurrent είναι διαφορετική του LOW = λογικό 0 τότε
    int x = Serial.parseInt();            //Στην μεταβλητή x εκχωρούμε την τιμή που έδωσε ο χρήστης στην σειριακή μετατρέποντας το σε ακέραιο 
    int d=0.1*(x+1)*k;                   //Τύπος του duty cycle
  while(1){                             //Δημιουργία επαναληπτικού ατέρμον βρόγχου
  digitalWrite(GREEN_LED, HIGH);       //Δίνει λογική τιμή 1 (HIGH) στο red led δηλαδή το ανάβει
  for(i=0; i<d; i++) {}               //Δημιουργία επαναληπτικού βρόγχου
  digitalWrite(GREEN_LED, LOW);      //Δίνει λογική τιμή 0 (LOW) στο led δηλαδή το σβήνει
  for(i=d; i<k; i++) {}             //Δημιουργία επαναληπτικού βρόγχου
  
    if(Serial.available())        //Αν η σειριακή είσοδος είναι διαθέσιμη
      { 
        x = Serial.parseInt();  //Στην μεταβλητή x εκχωρούμε την τιμή που έδωσε ο χρήστης στην σειριακή μετατρέποντας το σε ακέραιο 
        buttonCurrent = digitalRead(button);                       //Εκχώρηση στην μεταβλητή buttonCurrent την τιμή του Button (εαν πατήθηκε ή όχι)
        if(x==0)                                                  //Αν το x έχει την τιμή του ίση με 0
        {}                                                       //Συνεχίζει την επανάληψη 
        else if(x!=0 || buttonCurrent!=LOW){                    //Αν το x έχει την τιμή του ίση με 0 ή η κατάσταση του κουμπιού είναι διαφορετική απο το LOW
        break;                                                 //Σταματάει την επανάληψη
        }
      } 
   }
}
    else{                                                 //Αλλιώς
  

   while(buttonCurrent == LOW)                         //Εαν η τιμή του buttonCurrent είναι LOW = λογικό 0 τότε
    {
      digitalWrite(RED_LED, HIGH);                   //Δίνει λογική τιμή 1 (HIGH) στο red led δηλαδή το ανάβει
      for(i=0; i<j; i++) {p++;}                     //Δημιουργία επαναληπτικού βρόγχου και προσθήκη μετρητή
      digitalWrite(RED_LED, LOW);                  //Δίνει λογική τιμή 0 (LOW) στο led δηλαδή το σβήνει
      for(i=j; i<k; i++){ t++;}                   //Δημιουργία επαναληπτικού βρόγχου και προσθήκη μετρητή
      j=j+l;                                     //το l (-10)
      if(j>19000)                               //Αν το j > 19000
      {
        l=l*-1;                               //Mειώνουμε το l
      }
      if(j<5)                               //Αν το j < 5
      {
        l=l*-1;                           //Mειώνουμε το l
      }
        buttonCurrent = digitalRead(button);       //Εκχώρηση στην μεταβλητή buttonCurrent την τιμή του Button (εαν πατήθηκε ή όχι)
      }  
    if(p>t)                                      //Aν το p > t  
    {
         digitalWrite(RED_LED, HIGH);          //Δίνει λογική τιμή 1 (HIGH) στο red led δηλαδή το ανάβει
    }
    else                                     //Αλλιώς
    {
        digitalWrite(RED_LED, LOW);        //Δίνει λογική τιμή 0 (LOW) στο led δηλαδή το σβήνει

    }
   }
  }
}